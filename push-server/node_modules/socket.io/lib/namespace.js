/**
 * Module dependencies.
 */

var Socket = require('./socket');
var Emitter = require('events').EventEmitter;
var parser = require('socket.io-parser');
var debug = require('debug')('socket.io:namespace');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Namespace;

/**
 * Blacklisted events.
 */

exports.events = [
    'connect',    // for symmetry with client
    'connection',
    'newListener'
];

/**
 * Flags.
 */

exports.flags = [
    'json',
    'volatile'
];

/**
 * `EventEmitter#emit` reference.
 */

var emit = Emitter.prototype.emit;

/**
 * Namespace constructor.
 *
 * @param {Server} server instance
 * @param {Socket} name
 * @api private
 */
//在socket.io中,每个socket都有所属的Namespace,代表不同的通信通道。Namespace以字符串标识(name属性),例如'/'(默认)。
//需要注意的是,这个字符串和`实际`连接的url中uri没有任何关系。socket.io-client中io('http://localhost:8080/namespace', {path:'/socket.io'})实际连接用的url的path是/socket.io
//这个这个实际path需要在客户端和服务器段设置成一样的,才能完成http的upgrade过程,否则ws将不会完成websocket的upgrade过程,此时的表现是tcp连接正常建立,但是无法通过websocket通信。
//`实际`连接的url的uri部分,socket.io中默认是/socket.io; engine.io中默认是/socket.io; ws中客户端默认是/, 服务器端默认不限制
//所以在socket.io-client的url的path部分,其实是socket.io用来标识连接所属的namespace的; 连接建立之后,客户端发送{type:parser.CONNECT, nsp:'/namespace'}的packet到服务器。
//服务器的client捕获该消息,建立以该namespace标识的连接的socket实例,之后所以通过该socket发送出去的消息都会带上{nsp:namespace}属性; 默认的'/'namespace不需要发送,client在建立连接时自动建立相应socket
//客户端消息时,如果消息的nsp和本身的nsp不相等,则直接丢弃这条消息(socket.io-client/lib/socket.js:onpacket()的第一行)
//以上就是namespace的详细原理。从这里可以看出,namespace的概念就是组,client是具体的连接,socket是对连接在不同组的描述,即 client+nsp1 = socket1

function Namespace(server, name) {
    this.name = name;
    this.server = server;
    this.sockets = {};  //本通道的所有sockets
    this.connected = {}; //本通道中所有已连接的sockets
    this.fns = [];
    this.ids = 0;
    this.initAdapter();
}

/**
 * Inherits from `EventEmitter`.
 */

Namespace.prototype.__proto__ = Emitter.prototype;

/**
 * Apply flags from `Socket`.
 */

exports.flags.forEach(function (flag) {
    Namespace.prototype.__defineGetter__(flag, function () {
        this.flags = this.flags || {};
        this.flags[flag] = true;
        return this;
    });
});

/**
 * Initializes the `Adapter` for this nsp.
 * Run upon changing adapter by `Server#adapter`
 * in addition to the constructor.
 *
 * @api private
 */

Namespace.prototype.initAdapter = function () {
    this.adapter = new (this.server.adapter())(this);
};

/**
 * Sets up namespace middleware.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.use = function (fn) {
    this.fns.push(fn);
    return this;
};

/**
 * Executes the middleware for an incoming client.
 *
 * @param {Socket} socket that will get added
 * @param {Function} fn last fn call in the middleware
 * @api private
 */

Namespace.prototype.run = function (socket, fn) {
    var fns = this.fns.slice(0);
    if (!fns.length) return fn(null);

    function run(i) {
        fns[i](socket, function (err) {
            // upon error, short-circuit
            if (err) return fn(err);

            // if no middleware left, summon callback
            if (!fns[i + 1]) return fn(null);

            // go on to next
            run(i + 1);
        });
    }

    run(0);
};

/**
 * Targets a room when emitting.
 *
 * @param {String} name
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.to =
    Namespace.prototype['in'] = function (name) {
        this.rooms = this.rooms || [];
        if (!~this.rooms.indexOf(name)) this.rooms.push(name);
        return this;
    };

/**
 * Adds a new client.
 *
 * @return {Socket}
 * @api private
 */
// 生成一个针对某路连接(client)和本namespace的socket实例,触发该socket实例的onconnect方法,表示连接已建立
Namespace.prototype.add = function (client, fn) {
    debug('adding socket to nsp %s', this.name);
    var socket = new Socket(this, client);
    var self = this;
    this.run(socket, function (err) {
        process.nextTick(function () {
            if ('open' == client.conn.readyState) {
                if (err) return socket.error(err.data || err.message);

                // track socket
                self.sockets[socket.id] = socket;

                // it's paramount that the internal `onconnect` logic
                // fires before user-set events to prevent state order
                // violations (such as a disconnection before the connection
                // logic is complete)
                socket.onconnect();
                if (fn) fn();

                // fire user-set events
                self.emit('connect', socket);
                self.emit('connection', socket);
            } else {
                debug('next called after client was closed - ignoring socket');
            }
        });
    });
    return socket;
};

/**
 * Removes a client. Called by each `Socket`.
 *
 * @api private
 */

Namespace.prototype.remove = function (socket) {
    if (this.sockets.hasOwnProperty(socket.id)) {
        delete this.sockets[socket.id];
    } else {
        debug('ignoring remove for %s', socket.id);
    }
};

/**
 * Emits to all clients.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.emit = function (ev) {
    if (~exports.events.indexOf(ev)) {
        emit.apply(this, arguments);
    } else {
        // set up packet object
        var args = Array.prototype.slice.call(arguments);
        var parserType = parser.EVENT; // default
        if (hasBin(args)) {
            parserType = parser.BINARY_EVENT;
        } // binary

        var packet = {type: parserType, data: args};

        if ('function' == typeof args[args.length - 1]) {
            throw new Error('Callbacks are not supported when broadcasting');
        }

        this.adapter.broadcast(packet, {
            rooms: this.rooms,
            flags: this.flags
        });

        delete this.rooms;
        delete this.flags;
    }
    return this;
};

/**
 * Sends a `message` event to all clients.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.send =
    Namespace.prototype.write = function () {
        var args = Array.prototype.slice.call(arguments);
        args.unshift('message');
        this.emit.apply(this, args);
        return this;
    };

/**
 * Gets a list of clients.
 *
 * @return {Namespace} self
 * @api public
 */

Namespace.prototype.clients = function (fn) {
    this.adapter.clients(this.rooms, fn);
    // delete rooms flag for scenario:
    // .in('room').clients() (GH-1978)
    delete this.rooms;
    return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} compress if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Namespace.prototype.compress = function (compress) {
    this.flags = this.flags || {};
    this.flags.compress = compress;
    return this;
};
